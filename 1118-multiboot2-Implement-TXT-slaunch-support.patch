From 385569aa9be925c96e8112c69437241831152dd5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C5=82=20=C5=BBygowski?= <michal.zygowski@3mdeb.com>
Date: Thu, 1 Sep 2022 17:58:53 +0200
Subject: [PATCH 1118/1118] multiboot2: Implement TXT slaunch support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Michał Żygowski <michal.zygowski@3mdeb.com>
Signed-off-by: Tomasz Żyjewski <tomasz.zyjewski@3mdeb.com>
Signed-off-by: Krystian Hebel <krystian.hebel@3mdeb.com>
---
 grub-core/loader/multiboot.c       |  19 +++++-
 grub-core/loader/multiboot_elfxx.c | 102 ++++++++++++++++++++++++++---
 grub-core/loader/multiboot_mbi2.c  |  55 ++++++++++++++++
 include/grub/i386/txt.h            |   1 +
 4 files changed, 168 insertions(+), 9 deletions(-)

diff --git a/grub-core/loader/multiboot.c b/grub-core/loader/multiboot.c
index 3ab0c828c3ae..eb2da8546d9a 100644
--- a/grub-core/loader/multiboot.c
+++ b/grub-core/loader/multiboot.c
@@ -52,6 +52,7 @@
 #include <grub/i18n.h>
 #if defined (__i386__) || defined (__x86_64__)
 #include <grub/i386/slaunch.h>
+#include <grub/i386/txt.h>
 #endif
 
 GRUB_MOD_LICENSE ("GPLv3+");
@@ -164,7 +165,23 @@ efi_boot (struct grub_relocator *rel __attribute__ ((unused)),
 static void
 normal_boot (struct grub_relocator *rel, struct grub_relocator32_state state)
 {
-  state.edi = SLP_NONE;
+  grub_err_t err;
+  struct grub_slaunch_params *slparams = grub_slaunch_params();
+  state.edi = grub_slaunch_platform_type ();
+
+  if (state.edi == SLP_INTEL_TXT)
+    {
+      err = grub_txt_boot_prepare (slparams);
+
+      if (err != GRUB_ERR_NONE)
+	return;
+
+      /* Configure relocator GETSEC[SENTER] call. */
+      state.eax = GRUB_SMX_LEAF_SENTER;
+      state.ebx = slparams->sinit_acm_base;
+      state.ecx = slparams->sinit_acm_size;
+      state.edx = 0;
+    }
 
   grub_relocator32_boot (rel, state, 0);
 }
diff --git a/grub-core/loader/multiboot_elfxx.c b/grub-core/loader/multiboot_elfxx.c
index f2318e0d165d..47ba4c3f2746 100644
--- a/grub-core/loader/multiboot_elfxx.c
+++ b/grub-core/loader/multiboot_elfxx.c
@@ -34,6 +34,8 @@
 #error "I'm confused"
 #endif
 
+#include <grub/i386/slaunch.h>
+#include <grub/i386/txt.h>
 #include <grub/i386/relocator.h>
 
 #define CONCAT(a,b)	CONCAT_(a, b)
@@ -60,6 +62,9 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
   grub_uint32_t load_offset = 0, load_size;
   int i;
   void *source = NULL;
+  struct grub_slaunch_params *slparams = grub_slaunch_params();
+  grub_size_t total_size;
+  grub_uint32_t mle_hdr_offset;
 
   if (ehdr->e_ident[EI_MAG0] != ELFMAG0
       || ehdr->e_ident[EI_MAG1] != ELFMAG1
@@ -106,25 +111,86 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
 		    (long) mld->align, mld->preference, load_size,
 		    mld->avoid_efi_boot_services);
 
-      if (load_size > mld->max_addr || mld->min_addr > mld->max_addr - load_size)
+      if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+	{
+#ifndef GRUB_USE_MULTIBOOT2
+	  return grub_error (GRUB_ERR_BAD_OS, "Only multiboot2 supported for slaunch");
+#else
+	  /*
+	   * We allocate the the binary together with page tables to make one
+	   * contiguous block for MLE. We have to align up to PMR (2MB).
+	   */
+	  total_size = ALIGN_UP(load_size, GRUB_TXT_PMR_ALIGN);
+
+	  slparams->mle_size = total_size;
+
+	  slparams->mle_ptab_size = grub_txt_get_mle_ptab_size (total_size);
+	  slparams->mle_ptab_size = ALIGN_UP (slparams->mle_ptab_size, GRUB_TXT_PMR_ALIGN);
+
+	  /* Do not go below GRUB_TXT_PMR_ALIGN. */
+	  if (mld->align < GRUB_TXT_PMR_ALIGN)
+	    mld->align = GRUB_TXT_PMR_ALIGN;
+#endif
+	}
+      else
+	{
+	  total_size = load_size;
+	  slparams->mle_ptab_size = 0;
+	}
+
+      if (total_size > mld->max_addr || mld->min_addr > mld->max_addr - total_size)
 	return grub_error (GRUB_ERR_BAD_OS, "invalid min/max address and/or load size");
 
       err = grub_relocator_alloc_chunk_align_safe (GRUB_MULTIBOOT (relocator), &ch,
-						   mld->min_addr, mld->max_addr,
-						   load_size, mld->align ? mld->align : 1,
+						   mld->min_addr, mld->max_addr - total_size,
+						   total_size, mld->align ? mld->align : 1,
 						   mld->preference, mld->avoid_efi_boot_services);
 
       if (err)
-        {
-          grub_dprintf ("multiboot_loader", "Cannot allocate memory for OS image\n");
-          return err;
-        }
+	{
+	  grub_dprintf ("multiboot_loader", "Cannot allocate memory for OS image\n");
+	  return err;
+	}
 
       mld->load_base_addr = get_physical_target_address (ch);
       source = get_virtual_current_address (ch);
+      grub_memset (get_virtual_current_address (ch), 0, total_size);
+      grub_dprintf ("multiboot_loader", "load_base_addr=0x%lx, source=0x%lx\n",
+		    (long) mld->load_base_addr, (long) source);
+
+      if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+	{
+#ifndef GRUB_USE_MULTIBOOT2
+	  return grub_error (GRUB_ERR_BAD_OS, "Only multiboot2 supported for slaunch");
+#else
+	  slparams->mle_start = mld->load_base_addr;
+
+	  err = grub_relocator_alloc_chunk_align_safe (GRUB_MULTIBOOT (relocator), &ch,
+						       GRUB_MEMORY_MACHINE_UPPER_START,
+						       mld->load_base_addr - slparams->mle_ptab_size,
+						       slparams->mle_ptab_size, GRUB_TXT_PMR_ALIGN,
+						       GRUB_RELOCATOR_PREFERENCE_NONE, 1);
+	  if (err)
+	    {
+	      grub_dprintf ("multiboot_loader", "Cannot allocate memory for MLE page tables\n");
+	      return err;
+	    }
+
+	  slparams->mle_ptab_mem = get_virtual_current_address (ch);
+	  slparams->mle_ptab_target = (grub_uint64_t) get_physical_target_address (ch);
+	  grub_dprintf ("multiboot_loader", "mle_ptab_mem = %p, mle_ptab_target = %lx, mle_ptab_size = %x\n",
+			slparams->mle_ptab_mem, (unsigned long) slparams->mle_ptab_target,
+			(unsigned) slparams->mle_ptab_size);
+#endif
+	}
     }
   else
-    mld->load_base_addr = mld->link_base_addr;
+    {
+      mld->load_base_addr = mld->link_base_addr;
+      /* TODO: support non-relocatable */
+      if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+        return grub_error (GRUB_ERR_BAD_OS, "Non-relocatable ELF not supported with slaunch");
+    }
 
   grub_dprintf ("multiboot_loader", "relocatable=%d, link_base_addr=0x%x, "
 		"load_base_addr=0x%x\n", mld->relocatable,
@@ -180,6 +246,26 @@ CONCAT(grub_multiboot_load_elf, XX) (mbi_load_data_t *mld)
         }
     }
 
+  if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+    {
+      slparams->mle_header_offset = 0xffffffff;
+
+      for (mle_hdr_offset = 0;  mle_hdr_offset < 0x1000; mle_hdr_offset += 16)
+	{
+	  if ( !grub_memcmp ((void *)((grub_addr_t) source + mle_hdr_offset), GRUB_TXT_MLE_UUID, 16) )
+	    {
+	      slparams->mle_header_offset = mle_hdr_offset;
+	      break;
+	    }
+	}
+
+      if (slparams->mle_header_offset == 0xffffffff)
+	return grub_error (GRUB_ERR_BAD_ARGUMENT, "MLE header not found");
+
+      grub_dprintf ("slaunch", "slparams->mle_header_offset: 0x%08x\n",
+			slparams->mle_header_offset);
+    }
+
   for (i = 0; i < ehdr->e_phnum; i++)
     if (phdr(i)->p_vaddr <= ehdr->e_entry
 	&& phdr(i)->p_vaddr + phdr(i)->p_memsz > ehdr->e_entry)
diff --git a/grub-core/loader/multiboot_mbi2.c b/grub-core/loader/multiboot_mbi2.c
index 9a943d7bdd7c..14ac7137cd09 100644
--- a/grub-core/loader/multiboot_mbi2.c
+++ b/grub-core/loader/multiboot_mbi2.c
@@ -36,6 +36,9 @@
 #include <grub/i18n.h>
 #include <grub/net.h>
 #include <grub/lib/cmdline.h>
+#include <grub/i386/memory.h>
+#include <grub/i386/slaunch.h>
+#include <grub/i386/txt.h>
 
 #if defined (GRUB_MACHINE_EFI)
 #include <grub/efi/efi.h>
@@ -277,6 +280,9 @@ grub_multiboot2_load (grub_file_t file, const char *filename)
  
   if (addr_tag)
     {
+      if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+	return grub_error (GRUB_ERR_BAD_OS, "Slaunch not supported with multiboot addr tag");
+
       grub_uint64_t load_addr = (addr_tag->load_addr + 1)
 	? addr_tag->load_addr : (addr_tag->header_addr
 				 - ((char *) header - (char *) mld.buffer));
@@ -390,6 +396,50 @@ grub_multiboot2_load (grub_file_t file, const char *filename)
     err = grub_multiboot2_set_console (GRUB_MULTIBOOT2_CONSOLE_EGA_TEXT,
 				       accepted_consoles,
 				       0, 0, 0, console_required);
+
+  if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+    {
+      grub_relocator_chunk_t ch;
+      struct grub_slaunch_params *slparams = grub_slaunch_params();
+
+      if (grub_relocator_alloc_chunk_align_safe (grub_multiboot2_relocator, &ch, 0x1000000,
+						 UP_TO_TOP32 (GRUB_SLAUNCH_TPM_EVT_LOG_SIZE),
+						 GRUB_SLAUNCH_TPM_EVT_LOG_SIZE, GRUB_PAGE_SIZE,
+						 GRUB_RELOCATOR_PREFERENCE_HIGH, 1))
+	{
+	  grub_free (mld.buffer);
+	  return grub_error (GRUB_ERR_OUT_OF_MEMORY, "Could not allocate TPM event log area");
+	}
+
+      slparams->tpm_evt_log_base = get_physical_target_address (ch);
+      slparams->tpm_evt_log_size = GRUB_SLAUNCH_TPM_EVT_LOG_SIZE;
+
+      grub_memset (get_virtual_current_address (ch), 0, slparams->tpm_evt_log_size);
+
+      grub_dprintf ("multiboot_loader", "tpm_evt_log_base = %lx, tpm_evt_log_size = %x\n",
+		    (unsigned long) slparams->tpm_evt_log_base,
+		    (unsigned) slparams->tpm_evt_log_size);
+
+      if (grub_relocator_alloc_chunk_align_safe (grub_multiboot2_relocator, &ch, 0x1000000,
+						 UP_TO_TOP32 (GRUB_MLE_AP_WAKE_BLOCK_SIZE),
+						 GRUB_MLE_AP_WAKE_BLOCK_SIZE, GRUB_PAGE_SIZE,
+						 GRUB_RELOCATOR_PREFERENCE_NONE, 1))
+	{
+	  grub_free (mld.buffer);
+	  return grub_error (GRUB_ERR_OUT_OF_MEMORY, "Could not allocate AP wakeup block");
+	}
+
+      slparams->ap_wake_block = get_physical_target_address (ch);
+      slparams->ap_wake_block_size = GRUB_MLE_AP_WAKE_BLOCK_SIZE;
+
+      grub_memset ((void *) (grub_addr_t)slparams->ap_wake_block, 0, slparams->ap_wake_block_size);
+      grub_dprintf ("multiboot_loader", "ap_wake_block = %lx, ap_wake_block_size = %lx\n",
+		    (unsigned long) slparams->ap_wake_block,
+		    (unsigned long) slparams->ap_wake_block_size);
+
+      grub_txt_setup_mle_ptab (slparams);
+    }
+
   return err;
 }
 
@@ -722,7 +772,12 @@ grub_multiboot2_make_mbi (grub_uint32_t *target)
 
   ptrorig = get_virtual_current_address (ch);
 #if defined (__i386__) || defined (__x86_64__)
+  struct grub_slaunch_params *slparams = grub_slaunch_params();
+
   *target = get_physical_target_address (ch);
+  /* Save MBI pointer in the TXT heap area */
+  if (grub_slaunch_platform_type () == SLP_INTEL_TXT)
+    slparams->boot_params_addr = *target;
 #elif defined (__mips)
   *target = get_physical_target_address (ch) | 0x80000000;
 #else
diff --git a/include/grub/i386/txt.h b/include/grub/i386/txt.h
index a8ac569968c7..6166f17ff5ee 100644
--- a/include/grub/i386/txt.h
+++ b/include/grub/i386/txt.h
@@ -101,6 +101,7 @@ struct grub_txt_acm_header
 } GRUB_PACKED;
 
 #define GRUB_TXT_ACM_UUID "\xaa\x3a\xc0\x7f\xa7\x46\xdb\x18\x2e\xac\x69\x8f\x8d\x41\x7f\x5a"
+#define GRUB_TXT_MLE_UUID "\x5a\xac\x82\x90\x6f\x47\xa7\x74\x0f\x5c\x55\xa2\xcb\x51\xb6\x42"
 
 #define GRUB_TXT_ACM_CHIPSET_TYPE_BIOS		0
 #define GRUB_TXT_ACM_CHIPSET_TYPE_SINIT		1
-- 
2.17.1

